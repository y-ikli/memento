{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil","text":""},{"location":"#about-this-website","title":"\ud83d\uddc2\ufe0f About This Website","text":"<p>This site serves as both a personal knowledge base \u2014 a memento of the technologies and tools I explore \u2014 and a portfolio showcasing selected projects I\u2019ve worked on or am currently developing.</p> <p>It reflects my ongoing learning journey, practical experience, and areas of technical interest, with the goal of deepening my understanding while making useful resources available to others.</p> <p>Please note: as some of my professional experiences involved sensitive environments where privacy and confidentiality are paramount, no proprietary data, internal resources, or privileged information are shared on this site.</p>"},{"location":"#about-me","title":"About me","text":"<p>Younes IKLI</p> <p></p> <p>My journey into technology began in 2007 with a deep fascination for GNU/Linux systems and the philosophy of free and open-source software.</p> <p>Driven to deepen my expertise, I undertook a rigorous academic path while working as a teacher. I earned a Bachelor's degree in Mathematics and Computer Science, a Master's in Computer Science Education (MEEF), and a Master's in Applied Data Science for Healthcare. These studies were complemented by 10 months of internships in data science and engineering, as well as a professional machine learning project in collaboration with CHU Lille and the Clinical Investigation Centre.</p> <p>This journey reflects not only my dedication to growth and continuous learning, but also the perseverance, adaptability, and technical curiosity that shape my professional mindset. I bring a strong sense of responsibility and a deep commitment to ethical and impactful work.</p>"},{"location":"#passion-becomes-profession","title":"Passion Becomes Profession","text":"<p>As an R&amp;D Engineer at the Inria Centre, University of Lille, I design scalable, privacy-aware data pipelines for federated learning research.</p>"},{"location":"#technical-skills","title":"\ud83d\udd27 Technical Skills","text":"<p>Programming: Python, SQL, Bash Data Engineering: Pandas, PySpark DevOps: Docker, GitLab CI Development Practices: Git, Clean Code, TDD</p>"},{"location":"#currently-expanding-skills-in","title":"\ud83d\udcda Currently Expanding Skills In:","text":"<ul> <li>Google Cloud Platform (GCP)</li> <li>dbt (Data Build Tool)</li> <li>Kubernetes</li> </ul>"},{"location":"#core-attributes","title":"\ud83c\udf1f Core Attributes","text":"<ul> <li>Growth Mindset: Focused on continuous improvement</li> <li>Responsibility: Strong commitment to accountability</li> <li>Confidentiality: Upholding data privacy and ethics</li> <li>Curiosity: Passionate about exploring new technologies</li> </ul> <p>\ud83d\udceb Contact Information</p> <ul> <li> <p>Email: younes.ikli@gmail.com </p> </li> <li> <p>Website: y-ikli.github.io/memento </p> </li> <li> <p>LinkedIn: linkedin.com/in/younes-ikli</p> </li> </ul> <p>Author : Younes IKLI  </p> <p>Last update : 2025-05-04T15:05:30Z</p>"},{"location":"clean_code/memento_clean_code/","title":"Memento Clean Code","text":""},{"location":"clean_code/memento_clean_code/#introduction-to-clean-code-in-python","title":"Introduction to Clean Code in Python","text":"<p>What is Clean Code? - Clean code is code that is easy to read, understand, and maintain. - It follows best practices and conventions to ensure the codebase is efficient, modular, and understandable. - Clean code increases collaboration and reduces technical debt.</p>"},{"location":"clean_code/memento_clean_code/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you should have: - A basic understanding of Python programming. - Familiarity with software development principles and practices.</p>"},{"location":"clean_code/memento_clean_code/#naming-conventions","title":"Naming Conventions","text":"<p>Use descriptive and meaningful names: - Variables, functions, and classes should clearly describe their purpose. <pre><code># Bad\nx = 10\n\n# Good\nuser_age = 10\n</code></pre></p> <p>Use consistent naming styles: - Variables and functions: <code>snake_case</code> (e.g., <code>user_age</code>, <code>calculate_total</code>) - Classes: <code>CamelCase</code> (e.g., <code>UserProfile</code>, <code>OrderDetails</code>)</p> <p>Avoid using single-character names, except for loop counters: <pre><code># Bad\nn = 5\nfor x in range(n):\n    pass\n</code></pre></p>"},{"location":"clean_code/memento_clean_code/#functions","title":"Functions","text":"<p>Keep functions small and focused: - A function should do one thing and do it well. - Limit the number of lines per function (aim for fewer than 20\u201330 lines).</p> <pre><code># Bad\ndef process_data():\n    # some complex logic\n    pass\n\n# Good\ndef clean_data():\n    # cleaning logic\n    pass\n\ndef process_data():\n    # processing logic\n    pass\n</code></pre> <p>Function names should be action-oriented: - Use verbs or verb phrases (e.g., <code>get_user_data()</code>, <code>calculate_total_amount()</code>).</p> <p>Avoid side effects: - Functions should not modify external variables or states unless it\u2019s their primary job.</p>"},{"location":"clean_code/memento_clean_code/#comments","title":"Comments","text":"<p>Write meaningful comments, but don\u2019t over-comment: - Use comments to explain \u201cwhy\u201d something is done, not \u201cwhat\u201d is done (the code itself should explain the \u201cwhat\u201d). <pre><code># Bad\nx = 5  # Set x to 5\n\n# Good\n# Initialize x to represent the maximum number of retries\nx = 5\n</code></pre></p> <p>Avoid redundant comments: - If your code needs comments to explain simple operations, consider refactoring.</p>"},{"location":"clean_code/memento_clean_code/#code-readability","title":"Code Readability","text":"<p>Use consistent indentation: - Stick to 4 spaces per indentation level, as per PEP8.</p> <p>Avoid deeply nested code: - If you have too many nested levels, refactor the code into smaller functions or use early returns. <pre><code># Bad\nif condition:\n    if another_condition:\n        if yet_another_condition:\n            do_something()\n\n# Good\nif not condition:\n    return\nif not another_condition:\n    return\ndo_something()\n</code></pre></p> <p>Limit line length to 79 characters: - This improves readability, especially in terminals or text editors with limited width.</p>"},{"location":"clean_code/memento_clean_code/#avoiding-duplication","title":"Avoiding Duplication","text":"<p>Don\u2019t repeat yourself (DRY principle): - If the same code appears multiple times, extract it into a function. <pre><code># Bad\nuser_data = get_user_data()\nprocess_data(user_data)\n\nuser_data = get_user_data()\nprocess_data(user_data)\n\n# Good\ndef get_and_process_data():\n    user_data = get_user_data()\n    process_data(user_data)\n</code></pre></p> <p>Use constants and configurations for repeated values: <pre><code># Bad\ndef calculate_discount(price):\n    return price * 0.1\n\n# Good\nDISCOUNT_RATE = 0.1\ndef calculate_discount(price):\n    return price * DISCOUNT_RATE\n</code></pre></p>"},{"location":"clean_code/memento_clean_code/#error-handling","title":"Error Handling","text":"<p>Use exceptions, not error codes: - Python\u2019s exceptions are more readable and maintainable than using error codes. <pre><code># Bad\nif some_condition:\n    return -1  # error code\n\n# Good\nif some_condition:\n    raise ValueError(\"Invalid condition\")\n</code></pre></p> <p>Handle exceptions appropriately: - Only catch exceptions that you can handle, and avoid catching generic exceptions like <code>except Exception</code>. <pre><code># Bad\ntry:\n    # some code\nexcept Exception:\n    pass\n\n# Good\ntry:\n    # some code\nexcept ValueError as e:\n    print(f\"Handled value error: {e}\")\n</code></pre></p>"},{"location":"clean_code/memento_clean_code/#code-organization","title":"Code Organization","text":"<p>Group related functions into classes or modules: - Organize code into logical components (e.g., data processing, utilities). - Keep related classes and functions together, and ensure a clear hierarchy. <pre><code># Good: Modular design\nclass User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nclass UserProfile:\n    def __init__(self, user):\n        self.user = user\n\n    def display(self):\n        print(self.user.name)\n</code></pre></p> <p>Avoid long classes and modules: - Break them down into smaller, reusable pieces where possible.</p>"},{"location":"clean_code/memento_clean_code/#refactoring","title":"Refactoring","text":"<p>Refactor regularly: - As your codebase grows, revisit code for improvements. - Don\u2019t be afraid to refactor to make the code more readable and maintainable.</p>"},{"location":"clean_code/memento_clean_code/#testing","title":"Testing","text":"<p>Write tests for your code: - Tests help ensure code correctness and prevent regressions. - Use unit tests and integration tests to cover edge cases.</p> <p>Use descriptive test names: - Test names should explain what the test does. <pre><code># Bad\ndef test_func():\n    pass\n\n# Good\ndef test_calculate_discount_applies_10_percent():\n    pass\n</code></pre></p>"},{"location":"clean_code/memento_clean_code/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - Clean code is readable, maintainable, and follows best practices. - Use meaningful names, small functions, and avoid code duplication. - Refactor and write tests to keep code quality high.</p> <p>Next Steps: - Learn about design patterns and how they improve code structure. - Dive deeper into Python\u2019s PEP8 guidelines for further best practices. - Explore test-driven development (TDD) and automated testing tools.</p> <p>Last update : 2025-05-04T19:34:16Z</p>"},{"location":"dbt/memento_dbt/","title":"Memento DBT","text":""},{"location":"dbt/memento_dbt/#introduction-to-dbt-data-build-tool","title":"Introduction to dbt (Data Build Tool)","text":"<p>What is dbt? - dbt is a command-line tool that enables data analysts and engineers to transform data in their warehouse more effectively. - It helps manage data transformations using SQL and software engineering best practices like modularity, testing, and documentation. - Commonly used with data warehouses like Snowflake, BigQuery, Redshift, and Databricks.</p>"},{"location":"dbt/memento_dbt/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you\u2019ll need: - Python (3.7+) - Access to a supported data warehouse (e.g., Snowflake, BigQuery) - Basic knowledge of SQL and command-line interface - Docker (for containerized dbt setup, optional)</p>"},{"location":"dbt/memento_dbt/#setting-up-dbt-with-docker","title":"Setting Up dbt with Docker","text":"<p>Why use Docker? - Isolates dependencies - Ensures reproducibility - Easy setup for teams Run dbt with Docker: <pre><code>docker run -it --rm \\\n  --name dbt \\\n  -v $(pwd):/usr/app \\\n  -w /usr/app \\\n  ghcr.io/dbt-labs/dbt-core:1.7.0 debug\n</code></pre></p>"},{"location":"dbt/memento_dbt/#creating-a-dbt-project","title":"Creating a dbt Project","text":"<p>Initialize a new project: <pre><code>dbt init my_project\n</code></pre> - Creates a directory structure with dbt_config, models, tests, and documentation folders</p>"},{"location":"dbt/memento_dbt/#configure-your-connection","title":"Configure Your Connection","text":"<p>Edit <code>profiles.yml</code>: - Located at <code>~/.dbt/profiles.yml</code> - Configure according to your warehouse (example for Snowflake): <pre><code>my_project:\n  target: dev\n  outputs:\n    dev:\n      type: snowflake\n      account: your_account\n      user: your_user\n      password: your_password\n      role: your_role\n      database: your_database\n      warehouse: your_warehouse\n      schema: your_schema\n</code></pre></p>"},{"location":"dbt/memento_dbt/#building-your-first-model","title":"Building Your First Model","text":"<p>Create a SQL file in <code>models/</code>: - Example: <code>models/my_first_model.sql</code> <pre><code>SELECT *\nFROM {{ ref('raw_customers') }}\nWHERE is_active = TRUE\n</code></pre> - <code>ref()</code> is a dbt macro that manages dependencies between models Run dbt models: <pre><code>dbt run\n</code></pre></p>"},{"location":"dbt/memento_dbt/#testing-your-models","title":"Testing Your Models","text":"<p>Create a test in <code>models/tests/</code>: <pre><code>version: 2\nmodels:\n  - name: my_first_model\n    tests:\n      - unique:\n          column_name: id\n      - not_null:\n          column_name: id\n</code></pre> Run tests: <pre><code>dbt test\n</code></pre></p>"},{"location":"dbt/memento_dbt/#documenting-models","title":"Documenting Models","text":"<p>Add descriptions in YAML: <pre><code>models:\n  - name: my_first_model\n    description: \"This model filters active customers.\"\n    columns:\n      - name: id\n        description: \"Unique identifier for each customer\"\n</code></pre> Generate docs: <pre><code>dbt docs generate\ndbt docs serve\n</code></pre></p>"},{"location":"dbt/memento_dbt/#using-sources","title":"Using Sources","text":"<p>Define raw tables as sources: <pre><code>version: 2\nsources:\n  - name: raw\n    database: your_database\n    schema: raw_schema\n    tables:\n      - name: customers\n</code></pre> Refer to source in SQL: <pre><code>SELECT *\nFROM {{ source('raw', 'customers') }}\n</code></pre></p>"},{"location":"dbt/memento_dbt/#deployment-scheduling","title":"Deployment &amp; Scheduling","text":"<p>Use dbt Cloud or orchestrators like Airflow or Prefect to: - Schedule dbt runs - Monitor job health - Handle dependencies</p>"},{"location":"dbt/memento_dbt/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - dbt transforms data using modular SQL models and best practices - Use <code>ref()</code> and <code>source()</code> for maintainability - Automate testing and documentation - Docker helps keep dbt environments reproducible Next Steps: - Explore dbt packages: https://hub.getdbt.com - Learn about snapshots and incremental models - Connect dbt with your BI tools</p> <p>Last update : 2025-05-04T19:26:13Z</p>"},{"location":"docker/memento_docker/","title":"Memento Docker","text":""},{"location":"docker/memento_docker/#1-basic-docker-commands","title":"1. Basic Docker Commands","text":"<p>Check Docker Version <code>docker --version</code> - Displays the installed Docker version.</p> <p>Check Docker Info <code>docker info</code> - Displays detailed information about the Docker installation, including container and image counts.</p> <p>List All Running Containers <code>docker ps</code> - Lists all currently running containers.</p> <p>List All Containers (Including Stopped) <code>docker ps -a</code> - Lists all containers, including those that are stopped.</p> <p>List All Docker Images <code>docker images</code> - Displays all Docker images present locally.</p>"},{"location":"docker/memento_docker/#2-managing-docker-containers","title":"2. Managing Docker Containers","text":"<p>Run a Container from an Image <code>docker run &lt;image-name&gt;</code> - Runs a container from a specified image.</p> <p>Run a Container in Detached Mode <code>docker run -d &lt;image-name&gt;</code> - Runs the container in the background (detached mode).</p> <p>Run a Container with Interactive Terminal <code>docker run -it &lt;image-name&gt; /bin/bash</code> - Runs the container with an interactive terminal and opens a bash shell.</p> <p>Run a Container with Port Mapping <code>docker run -p 8080:80 &lt;image-name&gt;</code> - Maps port 8080 on the host to port 80 inside the container.</p> <p>Stop a Running Container <code>docker stop &lt;container-id&gt;</code> - Stops a running container.</p> <p>Start a Stopped Container <code>docker start &lt;container-id&gt;</code> - Starts a container that has been stopped.</p> <p>Restart a Container <code>docker restart &lt;container-id&gt;</code> - Restarts a running or stopped container.</p> <p>Remove a Container <code>docker rm &lt;container-id&gt;</code> - Removes a stopped container from your system.</p>"},{"location":"docker/memento_docker/#3-managing-docker-images","title":"3. Managing Docker Images","text":"<p>Pull an Image from Docker Hub <code>docker pull &lt;image-name&gt;</code> - Downloads a Docker image from Docker Hub or another registry.</p> <p>Build an Image from a Dockerfile <code>docker build -t &lt;image-name&gt; &lt;path&gt;</code> - Builds a Docker image from the specified Dockerfile located at the given path.</p> <p>Tag an Image <code>docker tag &lt;image-name&gt; &lt;new-image-name&gt;</code> - Tags an existing image with a new name.</p> <p>Remove an Image <code>docker rmi &lt;image-name&gt;</code> - Removes a Docker image from your local system.</p>"},{"location":"docker/memento_docker/#4-docker-volumes","title":"4. Docker Volumes","text":"<p>List All Volumes <code>docker volume ls</code> - Lists all Docker volumes on your system.</p> <p>Create a New Volume <code>docker volume create &lt;volume-name&gt;</code> - Creates a new volume.</p> <p>Remove a Volume <code>docker volume rm &lt;volume-name&gt;</code> - Removes a volume from your system.</p> <p>Mount a Volume to a Container <code>docker run -v &lt;volume-name&gt;:/path/in/container &lt;image-name&gt;</code> - Mounts a volume to a specific path inside the container.</p>"},{"location":"docker/memento_docker/#5-networking","title":"5. Networking","text":"<p>Understanding Docker Networks Docker creates default networks (<code>bridge</code>, <code>host</code>, <code>none</code>). List them with: <code>docker network ls</code> </p> <p>Create a Custom Network <code>docker network create my-network</code> - Isolate containers for secure communication.  </p> <p>Attach a Container to a Network <code>docker run -d --name my-nginx --net my-network nginx</code> - Launches an Nginx container on the custom network.  </p>"},{"location":"docker/memento_docker/#6-using-gitlab-docker-registry","title":"6. Using GitLab Docker Registry","text":"<p>Log in to GitLab Registry <code>docker login registry.gitlab.com</code> - Authenticate with your GitLab credentials or a personal access token.  </p> <p>Tag and Push an Image <code>docker build -t registry.gitlab.com/your-project/image:tag .</code> <code>docker push registry.gitlab.com/your-project/image:tag</code> - Builds and uploads the image to GitLab\u2019s registry.  </p> <p>Pull an Image <code>docker pull registry.gitlab.com/your-project/image:tag</code> - Retrieves the image for local use.  </p> <p>CI/CD Authentication In <code>.gitlab-ci.yml</code>, use: <code>docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY</code> - Automates registry access during pipelines.  </p> <p>Last update : 2025-05-04T18:47:58Z</p>"},{"location":"git/memento_git/","title":"Git Tutorial &amp; Practical Use Cases","text":"<p>This tutorial provides a structured guide to Git, covering basic commands, advanced features, and practical scenarios commonly encountered in software development.</p>"},{"location":"git/memento_git/#1-basic-setup","title":"1. Basic Setup","text":"<p>Before using Git, configure your name and email:</p> <pre><code>git config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n</code></pre> <p>Check your configuration:</p> <pre><code>git config --list\n</code></pre>"},{"location":"git/memento_git/#2-initializing-cloning-repositories","title":"2. Initializing &amp; Cloning Repositories","text":"<p>Initialize a New Repository</p> <pre><code>git init\n</code></pre> <p>Creates a new Git repository in the current directory.</p> <p>Clone an Existing Repository</p> <pre><code>git clone &lt;repository_url&gt;\n</code></pre> <p>Copies a remote repository to your local machine.</p>"},{"location":"git/memento_git/#3-basic-workflow","title":"3. Basic Workflow","text":"<p>Check Status</p> <pre><code>git status\n</code></pre> <p>Shows changed files and the current branch.</p> <p>Add Changes to Staging</p> <pre><code>git add &lt;file&gt;  # Add a specific file\ngit add .       # Add all changes\n</code></pre> <p>Commit Changes</p> <pre><code>git commit -m \"Commit message\"\n</code></pre> <p>Saves changes locally.</p> <p>View Commit History</p> <pre><code>git log --oneline --graph --decorate --all\n</code></pre>"},{"location":"git/memento_git/#4-branching-merging","title":"4. Branching &amp; Merging","text":"<p>Create a New Branch</p> <pre><code>git branch new-feature\n</code></pre> <p>Creates a new branch called <code>new-feature</code>.</p> <p>Switch Branch</p> <pre><code>git switch new-feature\n</code></pre> <p>Create and Switch to a New Branch</p> <p><pre><code>git switch -c new-feature\n</code></pre> Push the New Branch to the Remote Repository <pre><code>git push -u origin feature-xyz\n</code></pre> To avoid specifying -u on every push, configure Git to automatically set up tracking for new branches:</p> <p><pre><code>git config --global push.autoSetupRemote always\n</code></pre> With this configuration, after creating and switching to a new branch, you can simply use git push, and Git will automatically set up the upstream tracking. </p> <p>Merge Branches</p> <pre><code>git switch main\ngit merge new-feature\n</code></pre> <p>Merges <code>new-feature</code> into <code>main</code>.</p> <p>Delete a Branch</p> <pre><code>git branch -d new-feature\n</code></pre>"},{"location":"git/memento_git/#5-working-with-remote-repositories","title":"5. Working with Remote Repositories","text":"<ul> <li> <p>View connected remote repositories (e.g., GitHub, GitLab) <pre><code>git remote -v\n</code></pre> This command shows which remote repositories your local repository is connected to. For example, it might show the URL for GitHub or GitLab.</p> </li> <li> <p>Fetch changes from the remote repository without merging <pre><code>git fetch\n</code></pre> The git fetch command retrieves the latest updates from the remote repository but does not merge them into your local branch. It's useful to inspect what has changed on the remote before deciding to merge.</p> </li> <li> <p>Pull changes (Fetch + Merge) <pre><code>git pull origin main\n</code></pre> This command is a combination of git fetch and git merge. It fetches the latest updates from the main branch of the remote repository and automatically merges them into your current local branch.</p> </li> <li> <p>Push changes to the remote repository <pre><code>git push origin main\n</code></pre> The git push command pushes your local commits to the remote repository, making your changes available to others or deploying them.</p> </li> </ul>"},{"location":"git/memento_git/#6-undoing-changes","title":"6. Undoing Changes","text":"<p>Reset Staged Changes</p> <p><pre><code>git reset HEAD &lt;file&gt;\n</code></pre> This command removes a file from the staging area but leaves the changes in the working directory, allowing you to unstage a file without losing any modifications.</p> <p>Undo Last Commit (Keep Changes)</p> <p><pre><code>git reset --soft HEAD~1\n</code></pre> This command undoes the last commit but keeps the changes in your working directory and staging area. It's useful when you want to amend or rework the changes without losing them.</p> <p>Undo Last Commit (Lose Changes)</p> <p><pre><code>git reset --hard HEAD~1\n</code></pre> This command completely removes the last commit, including the changes in the working directory. Use it with caution as it will permanently delete the commit and any associated changes.</p>"},{"location":"git/memento_git/#7-stashing-work","title":"7. Stashing Work","text":"<p>Save Uncommitted Changes</p> <pre><code>git stash\n</code></pre> <p>List Stashes</p> <pre><code>git stash list\n</code></pre> <p>Restore Stashed Changes</p> <pre><code>git stash pop\n</code></pre>"},{"location":"git/memento_git/#8-rebasing-fixing-commits","title":"8. Rebasing &amp; Fixing Commits","text":"<p>Rebase a Branch</p> <pre><code>git switch feature-branch\ngit rebase main\n</code></pre> <p>Applies <code>feature-branch</code> commits on top of <code>main</code>.</p> <p>Squash Commits (Interactive Rebase)</p> <pre><code>git rebase -i HEAD~3\n</code></pre> <p>Allows combining commits.</p> <p>Amend Last Commit</p> <pre><code>git commit --amend -m \"New commit message\"\n</code></pre>"},{"location":"git/memento_git/#9-handling-merge-conflicts","title":"9. Handling Merge Conflicts","text":"<p>When a conflict occurs:</p> <ol> <li>Git will show conflicting files. Open them and manually fix the conflicts.</li> <li>After resolving, stage the fixed files:</li> </ol> <pre><code>git add &lt;file&gt;\n</code></pre> <ol> <li>Continue the merge:</li> </ol> <pre><code>git merge --continue\n</code></pre> <p>or</p> <pre><code>git rebase --continue\n</code></pre>"},{"location":"git/memento_git/#10-tags-releases","title":"10. Tags &amp; Releases","text":"<p>Create a Tag</p> <pre><code>git tag -a v1.0 -m \"Version 1.0\"\n</code></pre> <p>Push Tags to Remote</p> <pre><code>git push origin --tags\n</code></pre> <p>Delete a Tag</p> <pre><code>git tag -d v1.0\ngit push origin --delete v1.0\n</code></pre>"},{"location":"git/memento_git/#11-inspecting-debugging","title":"11. Inspecting &amp; Debugging","text":"<p>Show File Changes in a Commit</p> <pre><code>git show &lt;commit-hash&gt;\n</code></pre> <p>See Differences Between Branches</p> <pre><code>git diff main feature-branch\n</code></pre> <p>Blame (Find Who Changed a Line)</p> <pre><code>git blame &lt;file&gt;\n</code></pre> <p>12. Working with Multiple Repositories</p>"},{"location":"git/memento_git/#add-a-new-remote-repository","title":"Add a New Remote Repository","text":"<pre><code>git remote add upstream &lt;repo-url&gt;\n</code></pre> <p>Fetch and Merge from Another Repository</p> <pre><code>git fetch upstream\ngit merge upstream/main\n</code></pre>"},{"location":"git/memento_git/#13-practical-use-cases","title":"13. Practical Use Cases","text":"<p>Collaborative Feature Development</p> <p>Scenario: Multiple developers are working on different aspects of a new feature.</p> <p>Solution:</p> <ol> <li>Create a Feature Branch:</li> </ol> <pre><code>git checkout -b feature-branch\n</code></pre> <ol> <li>Push the Branch to Remote:</li> </ol> <pre><code>git push -u origin feature-branch\n</code></pre> <ol> <li>Developers Work on Their Parts:</li> </ol> <p>Each developer pulls the branch and commits their changes.</p> <ol> <li>Merge Feature Branch into Main:</li> </ol> <pre><code>git checkout main\ngit merge feature-branch\n</code></pre>"},{"location":"git/memento_git/#managing-diverged-branches","title":"Managing Diverged Branches","text":"<p>Scenario: Your local branch and the remote branch have diverged.</p> <p>Solution:</p> <ol> <li>Fetch Latest Changes:</li> </ol> <pre><code>git fetch origin\n</code></pre> <ol> <li>Rebase Your Changes:</li> </ol> <pre><code>git rebase origin/main\n</code></pre> <p>Resolve any conflicts and continue:</p> <pre><code>git add &lt;resolved-files&gt;\ngit rebase --continue\n</code></pre>"},{"location":"git/memento_git/#cleaning-up-commit-history","title":"Cleaning Up Commit History","text":"<p>Scenario: You have multiple small commits that you want to combine into one.</p> <p>Solution:</p> <ol> <li>Interactive Rebase:</li> </ol> <pre><code>git rebase -i HEAD~n\n</code></pre> <p>Replace <code>n</code> with the number of commits to review.</p> <ol> <li>In the Editor:</li> </ol> <p>Change <code>pick</code> to <code>squash</code> for commits you want to combine.</p> <ol> <li>Finalize Commit Message:</li> </ol> <p>Edit the commit message as desired, then save and exit.</p>"},{"location":"git/memento_git/#cherry-picking-specific-commits","title":"Cherry-Picking Specific Commits","text":"<p>Scenario: Apply a specific commit from one branch to another.</p> <p>Solution:</p> <ol> <li>Checkout Target Branch:</li> </ol> <pre><code>git checkout main\n</code></pre> <ol> <li>Cherry-Pick Commit:</li> </ol> <pre><code>git cherry-pick &lt;commit-hash&gt;\n</code></pre>"},{"location":"git/memento_git/#finding-bug-introducing-commits","title":"Finding Bug-Introducing Commits","text":"<p>Scenario: Identify the commit that introduced a bug.</p> <p>Solution:</p> <ol> <li>Start Bisect:</li> </ol> <pre><code>git bisect start\ngit bisect bad   # Current commit is bad\ngit bisect good &lt;commit-hash&gt;   # Known good commit\n</code></pre> <ol> <li>Test Commits:</li> </ol> <p>Git will checkout commits between good and bad. Test each and mark as good or bad:</p> <pre><code>git bisect good\n# or\ngit bisect bad\n</code></pre> <ol> <li>Reset Bisect:</li> </ol> <pre><code>git bisect reset\n</code></pre>"},{"location":"git/memento_git/#working-with-submodules","title":"Working with Submodules","text":"<p>Scenario: Include another Git repository within your project.</p> <p>Solution:</p> <ol> <li>Add Submodule:</li> </ol> <pre><code>git submodule add https://github.com/example/repo.git path/to/submodule\n</code></pre> <ol> <li>Initialize and Update Submodules:</li> </ol> <pre><code>git submodule update --init --recursive\n</code></pre> <ol> <li>Cloning Repository with Submodules:</li> </ol> <pre><code>git clone --recursive https://github.com/your/repo.git\n</code></pre>"},{"location":"git/memento_git/#tips-tricks","title":"Tips &amp; Tricks","text":""},{"location":"git/memento_git/#recovering-from-mistakes","title":"Recovering from Mistakes","text":"<p>Scenario: You made a mistake and need to revert to a previous state.</p> <p>Solution:</p> <pre><code>git reflog\n# Find the commit before the mistake\ngit reset --hard HEAD@{index}\n</code></pre>"},{"location":"git/memento_git/#amending-the-last-commit","title":"Amending the Last Commit","text":"<p>Scenario: You want to modify the last commit.</p> <p>Solution:</p> <pre><code># Make your changes\ngit add .\ngit commit --amend\n</code></pre> <p>Note: Avoid amending commits that have been pushed to shared branches.</p> <p>End of Tutorial</p> <p>Author : Younes IKLI  </p> <p>Last update : 2025-05-04T17:55:36Z</p>"},{"location":"kubernetes/memento_kubernetes/","title":"Memento Kubernetes","text":""},{"location":"kubernetes/memento_kubernetes/#introduction-to-kubernetes","title":"Introduction to Kubernetes","text":"<p>What is Kubernetes? - Kubernetes is an open-source platform for automating the deployment, scaling, and management of containerized applications. - It groups containers into logical units for easy management and discovery. - Kubernetes provides high availability, scalability, and fault tolerance for applications in production.</p>"},{"location":"kubernetes/memento_kubernetes/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you\u2019ll need: - A basic understanding of containers (Docker) - Access to a Kubernetes cluster (local or cloud-based) - kubectl (Kubernetes command-line tool) - A container registry (e.g., Docker Hub)</p>"},{"location":"kubernetes/memento_kubernetes/#setting-up-kubernetes-cluster","title":"Setting Up Kubernetes Cluster","text":"<p>Using Minikube for a Local Cluster: - Minikube allows you to run Kubernetes clusters locally.</p> <p>Install Minikube: <pre><code>brew install minikube\n</code></pre></p> <p>Start the Minikube Cluster: <pre><code>minikube start\n</code></pre></p> <p>Check Cluster Status: <pre><code>kubectl cluster-info\n</code></pre></p>"},{"location":"kubernetes/memento_kubernetes/#deploying-a-simple-application-on-kubernetes","title":"Deploying a Simple Application on Kubernetes","text":"<p>Create a deployment YAML file: - Example: <code>deployment.yaml</code> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:latest\n        ports:\n        - containerPort: 80\n</code></pre></p> <p>Deploy the application: <pre><code>kubectl apply -f deployment.yaml\n</code></pre></p> <p>Check the deployment status: <pre><code>kubectl get deployments\n</code></pre></p>"},{"location":"kubernetes/memento_kubernetes/#exposing-the-application","title":"Exposing the Application","text":"<p>Expose the deployment via a service: - Example: <code>service.yaml</code> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-service\nspec:\n  selector:\n    app: nginx\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 80\n  type: LoadBalancer\n</code></pre></p> <p>Create the service: <pre><code>kubectl apply -f service.yaml\n</code></pre></p> <p>Get the external IP of the service: <pre><code>kubectl get svc nginx-service\n</code></pre></p>"},{"location":"kubernetes/memento_kubernetes/#scaling-the-application","title":"Scaling the Application","text":"<p>Scale the number of replicas: <pre><code>kubectl scale deployment nginx-deployment --replicas=3\n</code></pre></p> <p>Verify the new number of pods: <pre><code>kubectl get pods\n</code></pre></p>"},{"location":"kubernetes/memento_kubernetes/#updating-the-application","title":"Updating the Application","text":"<p>Update the deployment with a new image: <pre><code>kubectl set image deployment/nginx-deployment nginx=nginx:latest\n</code></pre></p> <p>Check if the deployment was updated: <pre><code>kubectl rollout status deployment/nginx-deployment\n</code></pre></p>"},{"location":"kubernetes/memento_kubernetes/#deleting-resources","title":"Deleting Resources","text":"<p>Delete the service and deployment: <pre><code>kubectl delete -f service.yaml\nkubectl delete -f deployment.yaml\n</code></pre></p>"},{"location":"kubernetes/memento_kubernetes/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - Kubernetes helps with managing containerized applications in production with features like scaling, monitoring, and self-healing. - The key components include Pods, Deployments, and Services. - Kubernetes provides high availability, fault tolerance, and easy scaling.</p> <p>Next Steps: - Learn about ConfigMaps and Secrets for managing application configuration. - Explore Helm for easier package management in Kubernetes. - Experiment with Kubernetes in the cloud (e.g., GKE, EKS, AKS).</p> <p>Last update : 2025-05-04T19:26:13Z</p>"},{"location":"pyspark/memento_pyspark/","title":"Memento Pyspark","text":""},{"location":"pyspark/memento_pyspark/#pyspark-tutorial","title":"PySpark Tutorial","text":"<p>Introduction - PySpark is the Python API for Apache Spark, enabling scalable data processing using Python.</p> <p>Setup - Install PySpark: <pre><code>pip install pyspark\n</code></pre> - Import PySpark modules: <pre><code>from pyspark.sql import SparkSession\n</code></pre></p> <p>Creating a Spark Session <pre><code>spark = SparkSession.builder.appName(\"PySparkTutorial\").getOrCreate()\n</code></pre></p> <p>Creating DataFrames - From list of tuples: <pre><code>data = [(\"Alice\", 34), (\"Bob\", 45), (\"Cathy\", 29)]\ndf = spark.createDataFrame(data, [\"Name\", \"Age\"])\ndf.show()\n</code></pre> - From CSV file: <pre><code>df_csv = spark.read.csv(\"path/to/file.csv\", header=True, inferSchema=True)\ndf_csv.show()\n</code></pre></p> <p>Basic DataFrame Operations - Show schema: <pre><code>df.printSchema()\n</code></pre> - Select columns: <pre><code>df.select(\"Name\").show()\n</code></pre> - Filter rows: <pre><code>df.filter(df.Age &gt; 30).show()\n</code></pre> - Add column: <pre><code>from pyspark.sql.functions import col\ndf.withColumn(\"AgePlus10\", col(\"Age\") + 10).show()\n</code></pre> - Group and aggregate: <pre><code>df.groupBy(\"Age\").count().show()\n</code></pre></p> <p>Working with SQL - Register DataFrame as SQL view: <pre><code>df.createOrReplaceTempView(\"people\")\nsql_df = spark.sql(\"SELECT Name FROM people WHERE Age &gt; 30\")\nsql_df.show()\n</code></pre></p> <p>Data Types and Schema - Custom schema definition: <pre><code>from pyspark.sql.types import StructType, StructField, StringType, IntegerType\nschema = StructType([\n    StructField(\"Name\", StringType(), True),\n    StructField(\"Age\", IntegerType(), True)\n])\ndf_custom = spark.createDataFrame(data, schema)\ndf_custom.printSchema()\n</code></pre></p> <p>Joins <pre><code>df1 = spark.createDataFrame([(\"Alice\", \"Math\"), (\"Bob\", \"Science\")], [\"Name\", \"Subject\"])\ndf2 = spark.createDataFrame([(\"Alice\", 85), (\"Bob\", 90)], [\"Name\", \"Score\"])\njoined_df = df1.join(df2, on=\"Name\", how=\"inner\")\njoined_df.show()\n</code></pre></p> <p>Saving DataFrames - Write to CSV: <pre><code>df.write.csv(\"output/path\", header=True, mode=\"overwrite\")\n</code></pre> - Write to Parquet: <pre><code>df.write.parquet(\"output/path\", mode=\"overwrite\")\n</code></pre></p> <p>Working with RDDs - Create RDD: <pre><code>rdd = spark.sparkContext.parallelize([1, 2, 3, 4, 5])\n</code></pre> - Transform and collect: <pre><code>squared = rdd.map(lambda x: x * x)\nprint(squared.collect())\n</code></pre></p> <p>Stopping Spark Session <pre><code>spark.stop()\n</code></pre></p> <p>Conclusion - PySpark supports powerful big data processing in Python using DataFrames and RDDs. Use DataFrames for structured data and RDDs for lower-level operations.</p> <p>Last update : 2025-05-04T19:11:36Z</p>"},{"location":"python/memento_pandas/","title":"Memento Pandas","text":""},{"location":"python/memento_pandas/#introduction-to-pandas","title":"Introduction to Pandas","text":"<p>What is Pandas? - Pandas is a powerful open-source data analysis and manipulation library for Python. - It provides data structures like DataFrame and Series, which are perfect for handling structured data. - Commonly used for data cleaning, exploration, and analysis.</p>"},{"location":"python/memento_pandas/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you\u2019ll need: - Python (3.x or higher) - Pandas installed (use <code>pip install pandas</code> or <code>conda install pandas</code>) - A basic understanding of Python and data analysis concepts</p>"},{"location":"python/memento_pandas/#importing-pandas","title":"Importing Pandas","text":"<p>Importing the Pandas library: <pre><code>import pandas as pd\n</code></pre></p>"},{"location":"python/memento_pandas/#creating-dataframes","title":"Creating DataFrames","text":"<p>Create a DataFrame from a dictionary: <pre><code>data = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [25, 30, 35]}\ndf = pd.DataFrame(data)\nprint(df)\n</code></pre></p> <p>Create a DataFrame from a CSV file: <pre><code>df = pd.read_csv('file.csv')\n</code></pre></p>"},{"location":"python/memento_pandas/#basic-dataframe-operations","title":"Basic DataFrame Operations","text":"<p>View the first few rows of the DataFrame: <pre><code>df.head()\n</code></pre></p> <p>View basic summary statistics of the DataFrame: <pre><code>df.describe()\n</code></pre></p> <p>Get DataFrame info (e.g., number of non-null entries): <pre><code>df.info()\n</code></pre></p> <p>Access a single column: <pre><code>df['Name']\n</code></pre></p> <p>Access multiple columns: <pre><code>df[['Name', 'Age']]\n</code></pre></p>"},{"location":"python/memento_pandas/#data-selection-and-filtering","title":"Data Selection and Filtering","text":"<p>Select rows based on condition: <pre><code>df[df['Age'] &gt; 30]\n</code></pre></p> <p>Select specific rows and columns using <code>.loc[]</code>: <pre><code>df.loc[0:2, ['Name', 'Age']]\n</code></pre></p> <p>Select specific rows and columns using <code>.iloc[]</code>: <pre><code>df.iloc[0:2, [0, 1]]\n</code></pre></p>"},{"location":"python/memento_pandas/#modifying-dataframes","title":"Modifying DataFrames","text":"<p>Add a new column: <pre><code>df['Salary'] = [50000, 60000, 70000]\n</code></pre></p> <p>Remove a column: <pre><code>df.drop('Salary', axis=1, inplace=True)\n</code></pre></p> <p>Rename columns: <pre><code>df.rename(columns={'Name': 'Full Name'}, inplace=True)\n</code></pre></p> <p>Sort values by a column: <pre><code>df.sort_values(by='Age', ascending=False)\n</code></pre></p>"},{"location":"python/memento_pandas/#handling-missing-data","title":"Handling Missing Data","text":"<p>Check for missing values: <pre><code>df.isnull().sum()\n</code></pre></p> <p>Fill missing values with a specific value: <pre><code>df.fillna(0, inplace=True)\n</code></pre></p> <p>Drop rows with missing values: <pre><code>df.dropna(inplace=True)\n</code></pre></p>"},{"location":"python/memento_pandas/#grouping-and-aggregating","title":"Grouping and Aggregating","text":"<p>Group data by a column and calculate the mean: <pre><code>df.groupby('Age')['Salary'].mean()\n</code></pre></p> <p>Group by multiple columns and apply aggregation: <pre><code>df.groupby(['Age', 'Salary']).agg({'Name': 'count'})\n</code></pre></p>"},{"location":"python/memento_pandas/#merging-dataframes","title":"Merging DataFrames","text":"<p>Merge two DataFrames on a common column: <pre><code>df1 = pd.DataFrame({'ID': [1, 2, 3], 'Name': ['Alice', 'Bob', 'Charlie']})\ndf2 = pd.DataFrame({'ID': [1, 2, 4], 'Age': [25, 30, 35]})\nmerged_df = pd.merge(df1, df2, on='ID', how='inner')\n</code></pre></p> <p>Join DataFrames on an index: <pre><code>df1.set_index('ID', inplace=True)\ndf2.set_index('ID', inplace=True)\njoined_df = df1.join(df2)\n</code></pre></p>"},{"location":"python/memento_pandas/#plotting-with-pandas","title":"Plotting with Pandas","text":"<p>Plot a simple line chart: <pre><code>df['Age'].plot(kind='line')\n</code></pre></p> <p>Plot a histogram: <pre><code>df['Age'].plot(kind='hist')\n</code></pre></p> <p>Plot a scatter plot: <pre><code>df.plot(kind='scatter', x='Age', y='Salary')\n</code></pre></p>"},{"location":"python/memento_pandas/#exporting-data","title":"Exporting Data","text":"<p>Write a DataFrame to a CSV file: <pre><code>df.to_csv('output.csv', index=False)\n</code></pre></p> <p>Write a DataFrame to an Excel file: <pre><code>df.to_excel('output.xlsx', index=False)\n</code></pre></p>"},{"location":"python/memento_pandas/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - Pandas makes data manipulation and analysis easier with structures like DataFrame and Series. - You can import/export data, handle missing data, filter and aggregate data, and visualize results. - Pandas is a great tool for any data analysis project in Python.</p> <p>Next Steps: - Explore Pandas documentation for advanced operations. - Learn about multi-indexing and time series data manipulation. - Try using Pandas alongside NumPy and Matplotlib for full data science workflows.</p> <p>Last update : 2025-05-04T19:34:16Z</p>"},{"location":"python/memento_python/","title":"Memento Python","text":"<p>This memento summarizes some native Python features.</p>"},{"location":"python/memento_python/#type-hints-static-checking","title":"Type Hints &amp; Static Checking","text":"<p>Type hints help document your code and catch bugs early. Combined with tools like <code>mypy</code>, they enable static analysis without running the code.</p> <p>Basic Type Hints</p> <pre><code>def double(x: int) -&gt; int:\n    return x * 2\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}\"\n</code></pre> <p>Hints for Collections</p> <p><pre><code>from typing import List, Dict\n\ndef total(prices: List[float]) -&gt; float:\n    return sum(prices)\n\ndef extract_ids(data: List[Dict[str, int]]) -&gt; List[int]:\n    return [row[\"id\"] for row in data]\n</code></pre> - In first example prices are a list of floats. - In the second example, data is expected to be a list of dictionaries.Each dictionary maps strings to integers  This means you expect something like: <code>[{\"id\": 1}, {\"id\": 2}, {\"id\": 3}]</code></p> <p>Optional, Union, Literal</p> <p><pre><code>from typing import Optional, Union, Literal\n\ndef maybe_add(a: int, b: Optional[int]) -&gt; int:\n    return a + (b or 0)\n</code></pre> - b is optional, meaning it can be int or None (Optional[int]) - If b is None, use 0 instead - If b is an integer (e.g., 5), use it</p> <p><pre><code>def handle_event(type: Union[str, int]) -&gt; None:\n    print(type)\n</code></pre> - type can be a str or an int - The function returns nothing (None)</p> <p><pre><code>def status_color(status: Literal[\"ok\", \"error\", \"warning\"]) -&gt; str:\n    return {\"ok\": \"green\", \"error\": \"red\", \"warning\": \"yellow\"}[status]\n</code></pre> - <code>status: Literal[\"ok\", \"error\", \"warning\"]</code> restricts allowed values. - Helps prevent bugs by allowing only specific strings. - If you try another value, static checkers like <code>mypy</code> will raise an error.</p> <p>Other Special Types</p> <ul> <li><code>Any</code>: Indicates that a value can be of any type.</li> <li><code>Callable[[Arg1Type, Arg2Type], ReturnType]</code>: Represents a function or any other callable object with the specified argument types and return type.</li> <li><code>TypeVar</code>: Used for creating generic types.</li> </ul> <p>Type Hints Are Static Only</p> <p>Python does not enforce types at runtime. Type hints are for developers, IDEs, and tools like <code>mypy</code> \u2014 they make your code safer and more readable but don\u2019t stop bad values at runtime unless you add validation.   </p>"},{"location":"python/memento_python/#typeddict","title":"TypedDict","text":"<p><pre><code>from typing import TypedDict\n\nclass Product(TypedDict):\n    id: int\n    price: float\n\ndef apply_discount(p: Product) -&gt; float:\n    return p[\"price\"] * 0.9\n</code></pre> - TypedDict allows you to define the structure of a dictionary using class-like syntax. - It\u2019s perfect for describing JSON-like data, where keys and value types are known. - Fields are type-checked with tools like mypy, but at runtime it\u2019s still just a dict.</p>"},{"location":"python/memento_python/#namedtuples","title":"NamedTuples","text":"<p><pre><code>from typing import NamedTuple\n\nclass User(NamedTuple):\n    id: int\n    name: str\n</code></pre> - Combines tuple immutability with named fields and type hints. - Values are positionally fixed and read-only. - Supports dot notation: <code>user.name</code>, like an object.</p> <p>\u2705 Example: <pre><code>user = User(id=1, name=\"Alice\")\nprint(user.name)  # \u279c Alice\n</code></pre> - \ud83d\udd12 NamedTuples are immutable \u2014 you can\u2019t do <code>user.name = \"Bob\"</code></p>"},{"location":"python/memento_python/#mypy","title":"mypy","text":"<p>mypy scan a python file and report any type violations based on annotations (e.g., using TypedDict, List[int], etc.). <pre><code>mypy script.py\n</code></pre> - It analyzes your code without running it. - It checks if your type hints are correct. - It helps prevent bugs early by catching issues like missing return types, wrong arguments, etc.</p>"},{"location":"python/memento_python/#pydantic","title":"Pydantic","text":"<p>Pydantic is a library that uses Python type hints to enforce data structure and validate inputs at runtime. Why use Pydantic? - Enforces types at runtime - Converts compatible types (e.g., str \u279c int) - Raises clear validation errors on failure</p> <p>Basic Model:</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    is_active: bool = True\n</code></pre> <p>\u2705 Example: <pre><code>user = User(id=\"123\", name=\"Alice\")\nprint(user.id)  # \u279c 123 (auto-converted to int)\n</code></pre> Field Constraints:</p> <ul> <li>Field Constraints with Field(...) in Pydantic</li> <li>Use Field(...) to add validation rules on fields \u2014 like minimum length or positive values.</li> <li>This helps automatically enforce clean and correct data. \u2705 Example:</li> </ul> <p><pre><code>from pydantic import BaseModel, Field\n\nclass Product(BaseModel):    \n    name: str = Field(..., min_length=2)  # Name must have at least 2 characters\n    price: float = Field(..., gt=0)       # Price must be greater than 0\n</code></pre> \u2705 Valid input Product(name=\"Laptop\", price=1000.0)</p> <p>\u274c Invalid input (raises ValidationError) Product(name=\"A\", price=-10)</p> <ul> <li><code>min_length=2</code>: name must be at least 2 characters</li> <li><code>gt=0</code>: price must be greater than 0</li> <li><code>Field(...)</code>: required with constraints same as <code>Field(required=True)</code></li> </ul> <p>Nested Models Pydantic models can contain other Pydantic models as fields. This is powerful when working with structured or hierarchical data \u2014 like JSON from APIs.</p> <pre><code>class Address(BaseModel):\n    city: str\n    country: str\n\nclass Customer(BaseModel):\n    name: str\n    address: Address\n</code></pre> <p>\u2705 Example: <pre><code>cust = Customer(name=\"Bob\", address={\"city\": \"Paris\", \"country\": \"FR\"})\n</code></pre></p>"},{"location":"python/memento_python/#python-documentation-generator","title":"Python Documentation Generator","text":"<p><code>Pyment</code> is a simple tool for generating and enhancing docstrings in Python. It supports multiple formats, including Google, NumPy, and reST.  First, install Pyment using <code>pip</code>:</p> <p><pre><code>pip install pyment\n</code></pre> To generate and initialize docstrings for your Python file(with google format), run the following command: <code>pyment --init --format google &lt;your-python-file.py&gt;</code></p> <p>Generating Docstrings for Classes Pyment can also generate docstrings for Python classes.</p> <p><code>pyment --init --class &lt;your-python-file.py&gt;</code></p> <p>Generate Docstrings for Entire Project You can also generate docstrings for an entire project (all Python files) using Pyment.</p> <p><code>pyment --init --all</code> This command will go through all Python files in the current directory and generate docstrings for functions, methods, and classes.</p>"},{"location":"python/memento_python/#match","title":"match","text":"<p>match statement: It\u2019s used to match a value (expression) against several patterns.</p> <p>Patterns: These are conditions that specify what data to match, such as literal values, variable bindings, and complex patterns (like sequences, mappings, or classes).</p> <p>Basic Syntax:</p> <p><pre><code>match value:\n    case pattern1:\n        # code if value matches pattern1\n    case pattern2:\n        # code if value matches pattern2\n    case _:\n        # code for any other case (wildcard)\n</code></pre> Why Use match Over if-elif? - Readability: match provides a clean, concise way to handle complex data structures and patterns. - Flexibility: Supports powerful features like guards, destructuring, and multiple pattern matching. - Maintainability: It's easier to extend and modify as the logic is more declarative and expressive than if-elif. - In summary, match is a modern and robust alternative to if-elif chains for pattern matching, offering clearer, more maintainable code when working with complex data types.</p> <pre><code>def traiter_message(message):\n    match message:\n        case {'type': 'texte', 'contenu': contenu}:  # Correspond au dictionnaire avec les cl\u00e9s 'type' et 'contenu'\n            print(f\"Message texte re\u00e7u: {contenu}\")\n        case {'type': 'image', 'url': url}:  # Correspond au dictionnaire avec les cl\u00e9s 'type' et 'url'\n            print(f\"Image re\u00e7ue: {url}\")\n        case {'type': 'video', 'url': url, 'dur\u00e9e': dur\u00e9e}:  # Correspond au dictionnaire avec les cl\u00e9s 'type', 'url', et 'dur\u00e9e'\n            print(f\"Vid\u00e9o re\u00e7ue: {url}, dur\u00e9e: {dur\u00e9e} secondes\")\n        case _:\n            print(\"Type de message inconnu\")\n</code></pre>"},{"location":"python/memento_python/#map-and-reduce","title":"Map and Reduce","text":"<p><code>map()</code> and <code>reduce()</code> are functional programming tools in Python that allow concise transformation and aggregation of data collections.</p> <p>\ud83d\udd39 <code>map(func, iterable)</code></p> <ul> <li>Applies a function to each item in an iterable.</li> <li>Returns a new iterable (<code>map</code> object), often converted to a list.</li> </ul> <p>Example with a Named Function: <pre><code>def square(x: int) -&gt; int:\n    return x * x\n\nnums = [1, 2, 3, 4]\nsquares = list(map(square, nums))\nprint(squares)  # \u279c [1, 4, 9, 16]\n#example with Lambda function\nsquares = list(map(lambda x: x**2, nums))\nprint(squares)  # \u279c [1, 4, 9, 16]\n</code></pre></p>"},{"location":"python/memento_python/#decorators","title":"Decorators","text":"<p>A decorator is a special type of function in Python that allows you to \"decorate\" or modify another function (or method) without changing its actual code. It allows you to add functionality to an existing function in a clean, readable way. <pre><code>def my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n</code></pre> Common Built-in Decorators Python provides a few built-in decorators that are commonly used. Here are some examples:</p> <p>a. @staticmethod A staticmethod is a method that belongs to the class but doesn't require an instance of the class to be called. It does not have access to self (instance) or cls (class). <pre><code>class MyClass:\n    @staticmethod\n    def say_hello():\n        print(\"Hello from a static method!\")\n</code></pre></p> <p>b. @classmethod A classmethod is a method that works with the class itself rather than instances. It takes cls as the first argument, which refers to the class. <pre><code>class MyClass:\n    @classmethod\n    def say_hello(cls):\n        print(f\"Hello from {cls}!\")\n</code></pre> c. @property The @property decorator turns a method into a read-only property. Instead of calling it like a method, you access it like an attribute. <pre><code>class MyClass:\n    def __init__(self, x):\n        self._x = x\n\n    @property\n    def x(self):\n        return self._x\n</code></pre> Author : Younes IKLI  </p> <p>Last update : 2025-05-04T17:49:38Z</p>"},{"location":"sql/memento_sql/","title":"Memento SQL","text":""},{"location":"sql/memento_sql/#introduction-to-sql","title":"Introduction to SQL","text":"<p>What is SQL? - SQL (Structured Query Language) is the standard language used to interact with relational databases. - SQL allows you to query, insert, update, and delete data from a database. - It is used for database management and is supported by all major relational databases like MySQL, PostgreSQL, SQLite, and SQL Server.</p>"},{"location":"sql/memento_sql/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you\u2019ll need: - A basic understanding of databases and data structures. - Access to a database (e.g., MySQL, PostgreSQL) and a SQL client or interface.</p>"},{"location":"sql/memento_sql/#basic-sql-commands","title":"Basic SQL Commands","text":"<p>SELECT Query: - Retrieves data from one or more tables. <pre><code>SELECT column1, column2 FROM table_name;\n</code></pre> - To select all columns: <pre><code>SELECT * FROM table_name;\n</code></pre></p> <p>WHERE Clause: - Filters records based on a condition. <pre><code>SELECT * FROM table_name WHERE condition;\n</code></pre></p> <p>INSERT INTO: - Inserts new data into a table. <pre><code>INSERT INTO table_name (column1, column2) \nVALUES (value1, value2);\n</code></pre></p> <p>UPDATE: - Updates existing data in a table. <pre><code>UPDATE table_name \nSET column1 = value1, column2 = value2 \nWHERE condition;\n</code></pre></p> <p>DELETE: - Deletes data from a table. <pre><code>DELETE FROM table_name WHERE condition;\n</code></pre></p>"},{"location":"sql/memento_sql/#aggregate-functions","title":"Aggregate Functions","text":"<p>COUNT: - Counts the number of rows in a table or a group. <pre><code>SELECT COUNT(*) FROM table_name;\n</code></pre></p> <p>SUM: - Sums up values in a numeric column. <pre><code>SELECT SUM(column_name) FROM table_name;\n</code></pre></p> <p>AVG: - Finds the average of numeric values. <pre><code>SELECT AVG(column_name) FROM table_name;\n</code></pre></p> <p>MIN &amp; MAX: - Finds the minimum and maximum values in a column. <pre><code>SELECT MIN(column_name), MAX(column_name) FROM table_name;\n</code></pre></p>"},{"location":"sql/memento_sql/#joins","title":"Joins","text":"<p>INNER JOIN: - Combines rows from two tables based on a related column. <pre><code>SELECT column1, column2 \nFROM table1\nINNER JOIN table2 ON table1.common_column = table2.common_column;\n</code></pre></p> <p>LEFT JOIN: - Retrieves all records from the left table and the matched records from the right table. <pre><code>SELECT column1, column2\nFROM table1\nLEFT JOIN table2 ON table1.common_column = table2.common_column;\n</code></pre></p> <p>RIGHT JOIN: - Retrieves all records from the right table and the matched records from the left table. <pre><code>SELECT column1, column2\nFROM table1\nRIGHT JOIN table2 ON table1.common_column = table2.common_column;\n</code></pre></p> <p>FULL JOIN: - Retrieves records when there is a match in either table. <pre><code>SELECT column1, column2\nFROM table1\nFULL JOIN table2 ON table1.common_column = table2.common_column;\n</code></pre></p>"},{"location":"sql/memento_sql/#grouping-and-sorting","title":"Grouping and Sorting","text":"<p>GROUP BY: - Groups rows that have the same values into summary rows. <pre><code>SELECT column_name, COUNT(*)\nFROM table_name\nGROUP BY column_name;\n</code></pre></p> <p>HAVING Clause: - Filters records after the <code>GROUP BY</code> operation. <pre><code>SELECT column_name, COUNT(*)\nFROM table_name\nGROUP BY column_name\nHAVING COUNT(*) &gt; 1;\n</code></pre></p> <p>ORDER BY: - Sorts the result set in ascending or descending order. <pre><code>SELECT * FROM table_name ORDER BY column_name ASC;\nSELECT * FROM table_name ORDER BY column_name DESC;\n</code></pre></p>"},{"location":"sql/memento_sql/#subqueries","title":"Subqueries","text":"<p>Subquery in SELECT: - A query inside another query to filter results. <pre><code>SELECT column_name\nFROM table_name\nWHERE column_name IN (SELECT column_name FROM another_table WHERE condition);\n</code></pre></p> <p>Subquery in FROM: - Using a subquery in the <code>FROM</code> clause. <pre><code>SELECT alias.column_name\nFROM (SELECT column_name FROM table_name) AS alias;\n</code></pre></p>"},{"location":"sql/memento_sql/#advanced-sql-concepts","title":"Advanced SQL Concepts","text":"<p>CASE Statement: - Performs conditional logic within a query. <pre><code>SELECT column_name,\n       CASE \n           WHEN condition THEN result1\n           ELSE result2\n       END AS alias_name\nFROM table_name;\n</code></pre></p> <p>Window Functions (OVER): - Allows calculation across a set of rows related to the current row. <pre><code>SELECT column_name, \n       ROW_NUMBER() OVER (ORDER BY column_name) AS row_num\nFROM table_name;\n</code></pre></p> <p>Common Table Expressions (CTE): - A temporary result set that you can reference within a <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement. <pre><code>WITH cte_name AS (\n    SELECT column_name FROM table_name WHERE condition\n)\nSELECT * FROM cte_name;\n</code></pre></p> <p>Recursive CTE: - A CTE that references itself to retrieve hierarchical data. <pre><code>WITH RECURSIVE cte_name AS (\n    SELECT column_name FROM table_name WHERE condition\n    UNION ALL\n    SELECT column_name FROM table_name WHERE condition\n)\nSELECT * FROM cte_name;\n</code></pre></p> <p>Indexes: - A performance optimization for faster search and retrieval. <pre><code>CREATE INDEX index_name ON table_name(column_name);\n</code></pre></p> <p>Transactions: - Ensures a set of operations are completed successfully (or none at all). <pre><code>BEGIN TRANSACTION;\nUPDATE table_name SET column_name = value WHERE condition;\nCOMMIT;\n</code></pre> Rollback a Transaction: <pre><code>ROLLBACK;\n</code></pre></p>"},{"location":"sql/memento_sql/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - SQL allows you to interact with databases to retrieve, modify, and analyze data. - Basic SQL includes querying, filtering, and modifying data. - Advanced SQL features like joins, subqueries, window functions, and CTEs enhance query power.</p> <p>Next Steps: - Practice writing complex queries involving multiple joins, subqueries, and window functions. - Learn about database optimization techniques like indexing and query optimization. - Explore database design principles like normalization and denormalization.</p> <p>Last update : 2025-05-04T19:34:16Z</p>"},{"location":"tdd/memento_pytest/","title":"Memento pytest","text":""},{"location":"tdd/memento_pytest/#introduction-to-pytest","title":"Introduction to pytest","text":"<p>What is pytest? - <code>pytest</code> is a testing framework for Python that simplifies the process of writing and running tests. - It is widely used due to its easy syntax, rich feature set, and powerful plugins. - It supports fixtures, parametrization, assertions, and integrates easily with continuous integration (CI) tools.</p>"},{"location":"tdd/memento_pytest/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you\u2019ll need: - Basic understanding of Python programming. - Installation of <code>pytest</code> (install via <code>pip install pytest</code>). - Familiarity with writing basic Python functions and understanding unit tests.</p>"},{"location":"tdd/memento_pytest/#basic-pytest-usage","title":"Basic pytest Usage","text":"<p>Writing a Simple Test: - To get started, write a Python function that you want to test. - Create a test function using the <code>test_</code> prefix so <code>pytest</code> can identify it as a test.</p> <pre><code># math_operations.py\ndef add(a, b):\n    return a + b\n</code></pre> <p>Creating a Test File: - Create a new file with the prefix <code>test_</code> (e.g., <code>test_math_operations.py</code>).</p> <pre><code># test_math_operations.py\nfrom math_operations import add\n\ndef test_add():\n    assert add(2, 3) == 5\n</code></pre> <ul> <li>Run the tests with <code>pytest</code> by executing the following in the terminal: <pre><code>$ pytest test_math_operations.py\n</code></pre></li> </ul> <p>Test Output: - Pytest will run the tests and show output indicating whether the test passed or failed.</p>"},{"location":"tdd/memento_pytest/#running-pytest","title":"Running pytest","text":"<p>Running Tests from the Command Line: - Simply run <code>pytest</code> to find and execute all tests in the current directory and subdirectories.</p> <pre><code>$ pytest\n</code></pre> <p>Specifying Tests to Run: - You can specify individual tests or files. <pre><code>$ pytest test_math_operations.py::test_add\n</code></pre></p> <p>Running Tests with Verbose Output: - Use the <code>-v</code> flag to get more detailed output. <pre><code>$ pytest -v\n</code></pre></p>"},{"location":"tdd/memento_pytest/#assertions-in-pytest","title":"Assertions in pytest","text":"<p>Basic Assertions: - <code>pytest</code> uses Python's built-in <code>assert</code> statement for verifying conditions.</p> <pre><code>def test_add():\n    result = add(2, 3)\n    assert result == 5\n</code></pre> <p>Custom Error Messages: - You can add custom error messages to assertions for better debugging. <pre><code>def test_add():\n    result = add(2, 3)\n    assert result == 5, f\"Expected 5, but got {result}\"\n</code></pre></p>"},{"location":"tdd/memento_pytest/#fixtures","title":"Fixtures","text":"<p>What Are Fixtures? - Fixtures are used for setting up test environments or initializing data that is shared across multiple tests.</p> <p>Creating a Fixture: - Use the <code>@pytest.fixture</code> decorator to define a fixture.</p> <pre><code>import pytest\n\n@pytest.fixture\ndef sample_data():\n    return {\"name\": \"John\", \"age\": 30}\n</code></pre> <p>Using Fixtures in Tests: - You can pass fixtures as arguments to test functions.</p> <pre><code>def test_name(sample_data):\n    assert sample_data[\"name\"] == \"John\"\n</code></pre> <p>Running Tests with Fixtures: - When you run the test, pytest will automatically provide the fixture's return value.</p>"},{"location":"tdd/memento_pytest/#parametrization","title":"Parametrization","text":"<p>What is Parametrization? - Parametrization allows running a single test function with multiple sets of inputs and expected results.</p> <p>Using <code>@pytest.mark.parametrize</code>: - You can define multiple sets of parameters for a test function.</p> <pre><code>import pytest\n\n@pytest.mark.parametrize(\"a, b, expected\", [(2, 3, 5), (4, 5, 9), (0, 0, 0)])\ndef test_add(a, b, expected):\n    assert add(a, b) == expected\n</code></pre> <ul> <li>This will run the <code>test_add</code> three times with different values for <code>a</code>, <code>b</code>, and <code>expected</code>.</li> </ul>"},{"location":"tdd/memento_pytest/#pytest-markers","title":"pytest Markers","text":"<p>Using Markers for Custom Labels: - Markers are used to label or categorize tests.</p> <p>Marking Tests: - Use <code>@pytest.mark.&lt;marker&gt;</code> to assign a marker to a test function. <pre><code>import pytest\n\n@pytest.mark.slow\ndef test_add():\n    assert add(2, 3) == 5\n</code></pre></p> <p>Running Tests with a Marker: - You can run tests with specific markers using the <code>-m</code> flag. <pre><code>$ pytest -m slow\n</code></pre></p>"},{"location":"tdd/memento_pytest/#handling-test-failures","title":"Handling Test Failures","text":"<p>Handling Expected Failures: - Use <code>@pytest.mark.xfail</code> to mark a test that you expect to fail (it will not count as a failure).</p> <pre><code>@pytest.mark.xfail\ndef test_divide_by_zero():\n    assert 1 / 0 == 0\n</code></pre> <p>Skipping Tests: - Use <code>@pytest.mark.skip</code> to skip tests explicitly. <pre><code>@pytest.mark.skip\ndef test_skipped():\n    assert 2 + 2 == 4\n</code></pre></p> <p>Skipping Tests Based on Conditions: - Use <code>@pytest.mark.skipif</code> to skip tests if a condition is met. <pre><code>@pytest.mark.skipif(sys.platform == \"win32\", reason=\"Doesn't work on Windows\")\ndef test_linux_specific_feature():\n    assert 1 == 1\n</code></pre></p>"},{"location":"tdd/memento_pytest/#test-discovery","title":"Test Discovery","text":"<p>Test Discovery: - By default, <code>pytest</code> will automatically discover all files that start with <code>test_</code> and contain functions that begin with <code>test_</code>.</p> <p>Changing Test Discovery Rules: - You can change the default test discovery rules using the <code>--python-files</code> and <code>--python-functions</code> options.</p> <pre><code>$ pytest --python-files=\"*.py\" --python-functions=\"check_*\"\n</code></pre>"},{"location":"tdd/memento_pytest/#running-tests-in-parallel","title":"Running Tests in Parallel","text":"<p>Running Tests in Parallel with <code>pytest-xdist</code>: - You can speed up test execution by running tests in parallel using the <code>pytest-xdist</code> plugin.</p> <p>Install the Plugin: <pre><code>$ pip install pytest-xdist\n</code></pre></p> <p>Running Tests in Parallel: <pre><code>$ pytest -n 4\n</code></pre> - This will run the tests using 4 processes.</p>"},{"location":"tdd/memento_pytest/#pytest-plugins","title":"pytest Plugins","text":"<p>Useful pytest Plugins: - <code>pytest-cov</code>: Provides code coverage reports. - <code>pytest-mock</code>: Simplifies mocking in tests. - <code>pytest-django</code>: A plugin for testing Django applications.</p> <p>Installing Plugins: <pre><code>$ pip install pytest-cov\n</code></pre></p> <p>Using Plugins: <pre><code>$ pytest --cov=your_module test_your_module.py\n</code></pre></p>"},{"location":"tdd/memento_pytest/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - <code>pytest</code> simplifies testing by using Python's <code>assert</code> statement and providing rich features like fixtures, parametrization, and plugins. - TDD with <code>pytest</code> helps write clean, reliable, and maintainable tests. - Pytest\u2019s ability to run tests in parallel and extend functionality with plugins makes it powerful for larger test suites.</p> <p>Next Steps: - Practice writing tests with <code>pytest</code> for your projects. - Learn more about advanced <code>pytest</code> features like fixtures, mock testing, and working with external resources. - Explore additional <code>pytest</code> plugins to improve your testing workflow.</p> <p>Last update : 2025-05-04T19:34:16Z</p>"},{"location":"tdd/memento_tdd/","title":"Memento TDD","text":""},{"location":"tdd/memento_tdd/#introduction-to-test-driven-development-tdd","title":"Introduction to Test-Driven Development (TDD)","text":"<p>What is TDD? - Test-Driven Development (TDD) is a software development practice where tests are written before the actual code. - TDD follows a cycle of writing a test, implementing the feature, and then refactoring the code. - It helps ensure that the code is reliable, easy to maintain, and meets the specified requirements.</p>"},{"location":"tdd/memento_tdd/#prerequisites","title":"Prerequisites","text":"<p>Before starting, you\u2019ll need: - A basic understanding of software development and programming concepts. - Knowledge of unit testing frameworks like <code>unittest</code> (Python), <code>JUnit</code> (Java), or <code>RSpec</code> (Ruby). - A project setup with a version control system like Git.</p>"},{"location":"tdd/memento_tdd/#the-tdd-cycle","title":"The TDD Cycle","text":"<p>TDD follows a simple cycle known as the \"Red-Green-Refactor\" cycle:</p> <ol> <li>Red: Write a test that fails (since the feature isn\u2019t implemented yet).</li> <li>Green: Write the minimal code to pass the test.</li> <li>Refactor: Clean up the code, keeping it as simple and efficient as possible, while ensuring tests still pass.</li> </ol>"},{"location":"tdd/memento_tdd/#writing-tests-first","title":"Writing Tests First","text":"<p>Step 1: Write a Failing Test (Red Phase)</p> <ul> <li>Identify the feature or functionality you want to implement.</li> <li>Write a test that describes the expected behavior of this functionality.</li> <li>The test will fail initially because the functionality is not yet implemented.</li> </ul> <pre><code>import unittest\n\n# Example: Function to add two numbers\ndef add(a, b):\n    pass\n\nclass TestMathOperations(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <ul> <li>In the above example, the test will fail because the <code>add()</code> function doesn\u2019t return anything yet.</li> </ul> <p>Step 2: Write the Minimum Code to Pass the Test (Green Phase)</p> <ul> <li>Write just enough code to make the test pass.</li> <li>Avoid writing unnecessary code, focusing only on what\u2019s required to pass the test.</li> </ul> <pre><code>import unittest\n\ndef add(a, b):\n    return a + b\n\nclass TestMathOperations(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <ul> <li>Now the test passes because the <code>add()</code> function returns the sum of <code>a</code> and <code>b</code>.</li> </ul> <p>Step 3: Refactor the Code (Refactor Phase)</p> <ul> <li>Clean up the code if needed, without changing its functionality.</li> <li>Ensure the test cases still pass after the refactoring.</li> </ul> <pre><code>import unittest\n\n# In this case, no further refactoring needed, as the function is already simple.\n\ndef add(a, b):\n    return a + b\n\nclass TestMathOperations(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <ul> <li>The code remains simple, and you can be confident that it works as expected because the test passes.</li> </ul>"},{"location":"tdd/memento_tdd/#writing-more-tests","title":"Writing More Tests","text":"<p>Test Other Scenarios and Edge Cases: - After the basic functionality is covered, write additional tests to handle edge cases or error conditions.</p> <pre><code>import unittest\n\ndef add(a, b):\n    return a + b\n\nclass TestMathOperations(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(2, 3), 5)\n\n    def test_add_negative_numbers(self):\n        self.assertEqual(add(-1, -1), -2)\n\n    def test_add_zero(self):\n        self.assertEqual(add(0, 0), 0)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <ul> <li>In this case, the tests cover normal cases, negative numbers, and zero.</li> </ul>"},{"location":"tdd/memento_tdd/#benefits-of-tdd","title":"Benefits of TDD","text":"<p>Key Advantages: - Better code quality: Writing tests first helps you focus on the requirements and reduces the chances of introducing bugs. - Fewer bugs: Tests act as a safety net, catching issues early and ensuring your code behaves as expected. - Simpler code: TDD forces you to write minimal code to pass the test, which often results in simpler, more maintainable code. - Refactoring support: TDD ensures that you can refactor code with confidence because your tests guarantee that you haven\u2019t broken anything.</p>"},{"location":"tdd/memento_tdd/#common-pitfalls-in-tdd","title":"Common Pitfalls in TDD","text":"<p>Avoid the following common mistakes:</p> <ul> <li>Skipping the Refactor Step: It\u2019s tempting to write the minimum code that works, but skipping refactoring can lead to messy, hard-to-maintain code.</li> <li>Writing Tests for Every Line: Not every line of code needs to be tested. Focus on testing the critical logic and edge cases.</li> <li>Testing Too Early: Don\u2019t write tests for functionality you haven\u2019t thought through yet. Write tests once you have a clear idea of the behavior you want to implement.</li> </ul>"},{"location":"tdd/memento_tdd/#tdd-best-practices","title":"TDD Best Practices","text":"<p>Best Practices for Effective TDD:</p> <ul> <li>Write small, focused tests: Each test should cover one piece of functionality.</li> <li>Keep tests isolated: Tests should not depend on each other; each should be able to run independently.</li> <li>Test behavior, not implementation: Focus on what the code is supposed to do rather than how it\u2019s implemented.</li> <li>Write tests for edge cases: Think about the boundaries and exceptional cases, such as handling <code>None</code>, <code>0</code>, or negative numbers.</li> <li>Refactor often: After each change, refactor the code and ensure all tests still pass.</li> </ul>"},{"location":"tdd/memento_tdd/#tdd-in-practice","title":"TDD in Practice","text":"<p>Example of TDD Workflow: 1. Write a test for a new feature or change. 2. Run the test to see it fail. 3. Write the code that implements the feature. 4. Run the test again to ensure it passes. 5. Refactor the code for simplicity and readability. 6. Repeat the cycle for other features and changes.</p> <p>Test-First Mindset: - Adopt the mindset of writing tests first to improve design, ensure correctness, and prevent bugs.</p>"},{"location":"tdd/memento_tdd/#conclusion","title":"Conclusion","text":"<p>Key Takeaways: - TDD encourages writing tests before code, following the Red-Green-Refactor cycle. - It leads to higher-quality, maintainable, and bug-free code. - TDD improves design and simplifies refactoring.</p> <p>Next Steps: - Practice TDD with small projects and gradually apply it to larger systems. - Explore TDD in different programming languages and frameworks. - Learn about advanced topics like Mocking, Dependency Injection, and Continuous Integration (CI) for more effective testing workflows.</p> <p>Last update : 2025-05-04T19:34:16Z</p>"}]}