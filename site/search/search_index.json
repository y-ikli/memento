{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"clean_code/memento_clean_code/","title":"Memento Clean Code","text":""},{"location":"docker/memento_docker/","title":"Memento Docker","text":""},{"location":"git/memento_git/","title":"Memento Git","text":""},{"location":"python/memento_python/","title":"Memento Python","text":"<p>This memento summarizes some native Python features with structured examples.</p>"},{"location":"python/memento_python/#type-hints-static-checking","title":"Type Hints &amp; Static Checking","text":"<p>Type hints help document your code and catch bugs early. Combined with tools like <code>mypy</code>, they enable static analysis without running the code.</p>"},{"location":"python/memento_python/#basic-type-hints","title":"Basic Type Hints","text":"<pre><code>def double(x: int) -&gt; int:\n    return x * 2\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}\"\n</code></pre>"},{"location":"python/memento_python/#hints-for-collections","title":"Hints for Collections","text":"<p><pre><code>from typing import List, Dict\n\ndef total(prices: List[float]) -&gt; float:\n    return sum(prices)\n\ndef extract_ids(data: List[Dict[str, int]]) -&gt; List[int]:\n    return [row[\"id\"] for row in data]\n</code></pre> - In first example prices are a list of floats. - In the second example, data is expected to be a list of dictionaries.Each dictionary maps strings to integers  This means you expect something like: <code>[{\"id\": 1}, {\"id\": 2}, {\"id\": 3}]</code></p>"},{"location":"python/memento_python/#optional-union-literal","title":"Optional, Union, Literal","text":"<pre><code>from typing import Optional, Union, Literal\n\ndef maybe_add(a: int, b: Optional[int]) -&gt; int:\n    return a + (b or 0)\n</code></pre> Note <ul> <li>b is optional, meaning it can be int or None (Optional[int])</li> <li>If b is None, use 0 instead</li> <li>If b is an integer (e.g., 5), use it</li> </ul> <pre><code>def handle_event(type: Union[str, int]) -&gt; None:\n    print(type)\n</code></pre> Note <ul> <li>type can be a str or an int</li> <li>The function returns nothing (None)</li> </ul> <pre><code>def status_color(status: Literal[\"ok\", \"error\", \"warning\"]) -&gt; str:\n    return {\"ok\": \"green\", \"error\": \"red\", \"warning\": \"yellow\"}[status]\n</code></pre> Note <ul> <li><code>status: Literal[\"ok\", \"error\", \"warning\"]</code> restricts allowed values.</li> <li>Helps prevent bugs by allowing only specific strings.</li> <li>If you try another value, static checkers like <code>mypy</code> will raise an error.</li> </ul> <p>Type Hints Are Static Only</p> <p>Python does not enforce types at runtime. Type hints are for developers, IDEs, and tools like <code>mypy</code> \u2014 they make your code safer and more readable but don\u2019t stop bad values at runtime unless you add validation.   </p>"},{"location":"python/memento_python/#some-other-special-types","title":"Some other Special Types","text":"<ul> <li><code>Any</code>: Indicates that a value can be of any type.</li> <li><code>Union[T1, T2, ...]</code>: Used to indicate that a value can be one of several types.</li> <li><code>Optional[T]</code>: A shorthand for <code>Union[T, None]</code>, meaning the value could be of type <code>T</code> or <code>None</code>.</li> <li><code>Callable[[Arg1Type, Arg2Type], ReturnType]</code>: Represents a function or any other callable object with the specified argument types and return type.</li> <li><code>TypeVar</code>: Used for creating generic types.</li> </ul>"},{"location":"python/memento_python/#typeddict","title":"TypedDict","text":"<pre><code>from typing import TypedDict\n\nclass Product(TypedDict):\n    id: int\n    price: float\n\ndef apply_discount(p: Product) -&gt; float:\n    return p[\"price\"] * 0.9\n</code></pre> Note <ul> <li>TypedDict allows you to define the structure of a dictionary using class-like syntax. - It\u2019s perfect for describing JSON-like data, where keys and value types are known. - Fields are type-checked with tools like mypy, but at runtime it\u2019s still just a dict.</li> </ul>"},{"location":"python/memento_python/#namedtuples","title":"NamedTuples","text":"<pre><code>from typing import NamedTuple\n\nclass User(NamedTuple):\n    id: int\n    name: str\n</code></pre> Note <ul> <li>Combines tuple immutability with named fields and type hints.</li> <li>Values are positionally fixed and read-only.</li> <li>Supports dot notation: <code>user.name</code>, like an object.</li> </ul> <p>\u2705 Example: <pre><code>user = User(id=1, name=\"Alice\")\nprint(user.name)  # \u279c Alice\n</code></pre> - \ud83d\udd12 NamedTuples are immutable \u2014 you can\u2019t do <code>user.name = \"Bob\"</code></p>"},{"location":"python/memento_python/#run-mypy-to-check","title":"Run <code>mypy</code> to Check","text":"<p>mypy scan a python file and report any type violations based on annotations (e.g., using TypedDict, List[int], etc.). <pre><code>mypy script.py\n</code></pre> - It analyzes your code without running it. - It checks if your type hints are correct. - It helps prevent bugs early by catching issues like missing return types, wrong arguments, etc.</p> <p>We can add a config file <code>mypy.ini</code> to enforce rules, It tells mypy:</p> <ul> <li>How strict to be</li> <li>What files or modules to include/exclude</li> <li>Whether to allow missing type hints</li> <li>Whether to treat certain errors as warnings</li> <li>Project-specific overrides</li> </ul>"},{"location":"python/memento_python/#mypy-strict-true-enables-all-strict-checks-recommended-ignore_missing_imports-true-dont-fail-on-3rd-party-libraries-with-no-stubs-disallow_untyped_defs-true-force-you-to-type-all-function-defs-warn_unused_ignores-true-warn-if-you-ignore-something-unnecessarily-exclude-tests-dont-type-check-test-files","title":"<pre><code>[mypy]\nstrict = True                   # Enables all strict checks (recommended!)\nignore_missing_imports = True   # Don\u2019t fail on 3rd-party libraries with no stubs\ndisallow_untyped_defs = True    # Force you to type all function defs\nwarn_unused_ignores = True      # Warn if you ignore something unnecessarily\nexclude = tests/                # Don't type-check test files\n</code></pre>","text":""},{"location":"python/memento_python/#data-validation-with-pydantic","title":"Data Validation with Pydantic","text":"<p>Type hints in Python are static \u2014 they don\u2019t enforce anything at runtime. In real-world data engineering (APIs, configs, pipelines), we need runtime validation. Pydantic is a powerful library that uses Python type hints to enforce data structure and validate inputs at runtime.</p>"},{"location":"python/memento_python/#basic-model","title":"Basic Model","text":"<pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    is_active: bool = True\n</code></pre> <p>\u2705 Example: <pre><code>user = User(id=\"123\", name=\"Alice\")\nprint(user.id)  # \u279c 123 (auto-converted to int)\n</code></pre></p> Why use Pydantic? <ul> <li>Enforces types at runtime</li> <li>Converts compatible types (e.g., str \u279c int)</li> <li>Raises clear validation errors on failure</li> </ul>"},{"location":"python/memento_python/#field-constraints","title":"Field Constraints","text":"<pre><code>from pydantic import BaseModel, Field\n\nclass Product(BaseModel):\n    name: str = Field(..., min_length=2)\n    price: float = Field(..., gt=0)\n</code></pre> <p>\u2705 Example: <pre><code>Product(name=\"Laptop\", price=1000.0)  # \u2705 Valid\nProduct(name=\"A\", price=-10)          # \u274c ValidationError\n</code></pre></p> Field Constraints <ul> <li><code>min_length=2</code>: name must be at least 2 characters</li> <li><code>gt=0</code>: price must be greater than 0</li> <li><code>Field(...)</code>: required with constraints</li> </ul>"},{"location":"python/memento_python/#nested-models","title":"Nested Models","text":"<pre><code>class Address(BaseModel):\n    city: str\n    country: str\n\nclass Customer(BaseModel):\n    name: str\n    address: Address\n</code></pre> <p>\u2705 Example: <pre><code>cust = Customer(name=\"Bob\", address={\"city\": \"Paris\", \"country\": \"FR\"})\n</code></pre></p> Nested Models <ul> <li>Nested BaseModels are validated recursively</li> <li>Great for structured data like JSON config or API payloads</li> </ul>"},{"location":"python/memento_python/#custom-validation","title":"Custom Validation","text":"<pre><code>from pydantic import validator\n\nclass Event(BaseModel):\n    type: str\n    payload: dict\n\n    @validator(\"type\")\n    def must_be_known(cls, v):\n        if v not in {\"click\", \"view\", \"purchase\"}:\n            raise ValueError(\"Invalid event type\")\n        return v\n</code></pre> <p>\u2705 Example: <pre><code>Event(type=\"click\", payload={})       # \u2705\nEvent(type=\"unknown\", payload={})     # \u274c ValidationError\n</code></pre></p> \ud83d\udd0d Custom Logic <ul> <li>Validators allow custom logic on fields</li> <li>Raise <code>ValueError</code> to reject bad input</li> </ul>"},{"location":"python/memento_python/#tools-like-pydantic","title":"Tools like Pydantic","text":"<p>Pydantic is powerful, but not alone. We might also consider:</p> <ul> <li><code>TypedDict</code> \u2192 static-only, no runtime checks</li> <li><code>attrs</code> \u2192 high-performance data classes with validation</li> <li><code>marshmallow</code> \u2192 schema-based (de)serialization and validation</li> <li><code>typeguard</code> \u2192 simple runtime type enforcement with decorators</li> <li><code>Protobuf</code> \u2192 typed messages for streaming / microservices</li> </ul>"},{"location":"python/memento_python/#-in-large-scale-data-systems-combine-static-tools-mypy-pyright-with-runtime-checks-pydantic-or-protobuf-to-catch-issues-early-and-enforce-safety-in-production","title":"- In large-scale data systems, combine static tools (mypy, pyright) with runtime checks (Pydantic or Protobuf) to catch issues early and enforce safety in production.","text":""},{"location":"python/memento_python/#data-contracts-with-protobuf","title":"\ud83d\udd01 Data Contracts with Protobuf","text":"<p>For data engineers working with microservices, streaming, or cross-language systems, Protocol Buffers (Protobuf) provide a fast, strongly typed, and schema-first approach to data serialization.</p>"},{"location":"python/memento_python/#what-is-protobuf","title":"What is Protobuf?","text":"<ul> <li>Defines structured data with <code>.proto</code> schema files</li> <li>Generates code in multiple languages (Python, Go, Java\u2026)</li> <li>Perfect for APIs, Kafka events, gRPC, and long-term data contracts</li> </ul>"},{"location":"python/memento_python/#defining-a-schema-proto","title":"Defining a Schema (<code>.proto</code>)","text":"<pre><code>syntax = \"proto3\";\n\nmessage Event {\n  int64 id = 1;\n  string type = 2;\n  string payload = 3;\n}\n</code></pre> <ul> <li>Define message structure</li> <li>Fields have fixed types and unique IDs</li> <li>Supports primitives, enums, nesting, repeated fields, etc.</li> </ul>"},{"location":"python/memento_python/#generating-python-code","title":"Generating Python Code","text":"<pre><code># Install\npip install protobuf\n\n# Generate Python classes\nprotoc --python_out=. event.proto\n</code></pre> <p>This generates a Python class <code>Event</code> , we can import and use.</p>"},{"location":"python/memento_python/#using-generated-code","title":"Using Generated Code","text":"<pre><code>from event_pb2 import Event\n\nevent = Event(id=123, type=\"click\", payload=\"{}\")\nprint(event.type)         # \u279c click\nprint(event.SerializeToString())  # \u279c binary format\n</code></pre> <p>\u2705 Example: serialize the event and send it over a socket or Kafka.</p>"},{"location":"python/memento_python/#deserialization","title":"Deserialization","text":"<pre><code>data = event.SerializeToString()\n</code></pre>"},{"location":"python/memento_python/#on-the-receiving-side","title":"On the receiving side","text":"<pre><code>event2 = Event()\nevent2.ParseFromString(data)\nprint(event2.id)  # \u279c 123\n</code></pre> <ul> <li>We can safely parse and validate the binary payload using the generated schema.</li> <li>If the payload doesn't match, it fails fast.</li> </ul> Why Use Protobuf Instead of JSON? <ul> <li>Faster: compact binary format is smaller and faster than JSON</li> <li>Typed: strict field types prevent many bugs</li> <li>Evolvable: supports optional fields and versioning without breaking older clients</li> </ul> <ul> <li> <p>Use <code>mypy-protobuf</code> to generate <code>.pyi</code> stub files for better IDE/type checker support:     <pre><code>pip install mypy-protobuf\nprotoc --python_out=. --mypy_out=. schema.proto\n</code></pre></p> </li> <li> <p>Combine Protobuf messages with Kafka or gRPC for fast, safe communication.</p> </li> <li>Avoid tight coupling: keep <code>.proto</code> files in shared versioned repos for teams.</li> </ul>"},{"location":"python/memento_python/#python-documentation-generator","title":"Python Documentation Generator","text":"<p>Pyment is a simple tool for generating and enhancing docstrings in Python. It supports multiple formats, including Google, NumPy, and reST.  First, install Pyment using <code>pip</code>:</p> <p><pre><code>pip install pyment\n</code></pre> To generate and initialize docstrings for your Python file(with google format), run the following command: <code>pyment --init --format google &lt;your-python-file.py&gt;</code></p> <p>Generating Docstrings for Classes Pyment can also generate docstrings for Python classes.</p> <p><code>pyment --init --class &lt;your-python-file.py&gt;</code></p> <p>Generate Docstrings for Entire Project You can also generate docstrings for an entire project (all Python files) using Pyment.</p> <p><code>pyment --init --all</code> This command will go through all Python files in the current directory and generate docstrings for functions, methods, and classes.</p>"},{"location":"python/memento_python/#match","title":"match:","text":"<p>match statement: It\u2019s used to match a value (expression) against several patterns.</p> <p>Patterns: These are conditions that specify what data to match, such as literal values, variable bindings, and complex patterns (like sequences, mappings, or classes).</p> <p>Basic Syntax:</p> <p><pre><code>match value:\n    case pattern1:\n        # code if value matches pattern1\n    case pattern2:\n        # code if value matches pattern2\n    case _:\n        # code for any other case (wildcard)\n</code></pre> Why Use match Over if-elif? - Readability: match provides a clean, concise way to handle complex data structures and patterns. - Flexibility: Supports powerful features like guards, destructuring, and multiple pattern matching. - Maintainability: It's easier to extend and modify as the logic is more declarative and expressive than if-elif. - In summary, match is a modern and robust alternative to if-elif chains for pattern matching, offering clearer, more maintainable code when working with complex data types.</p> <pre><code>def traiter_message(message):\n    match message:\n        case {'type': 'texte', 'contenu': contenu}:  # Correspond au dictionnaire avec les cl\u00e9s 'type' et 'contenu'\n            print(f\"Message texte re\u00e7u: {contenu}\")\n        case {'type': 'image', 'url': url}:  # Correspond au dictionnaire avec les cl\u00e9s 'type' et 'url'\n            print(f\"Image re\u00e7ue: {url}\")\n        case {'type': 'video', 'url': url, 'dur\u00e9e': dur\u00e9e}:  # Correspond au dictionnaire avec les cl\u00e9s 'type', 'url', et 'dur\u00e9e'\n            print(f\"Vid\u00e9o re\u00e7ue: {url}, dur\u00e9e: {dur\u00e9e} secondes\")\n        case _:\n            print(\"Type de message inconnu\")\n</code></pre>"},{"location":"python/memento_python/#map-and-reduce","title":"Map and Reduce","text":"<p><code>map()</code> and <code>reduce()</code> are functional programming tools in Python that allow concise transformation and aggregation of data collections.</p>"},{"location":"python/memento_python/#mapfunc-iterable","title":"\ud83d\udd39 <code>map(func, iterable)</code>","text":"<ul> <li>Applies a function to each item in an iterable.</li> <li>Returns a new iterable (<code>map</code> object), often converted to a list.</li> </ul>"},{"location":"python/memento_python/#example-with-a-named-function","title":"\u2705 Example with a Named Function","text":"<pre><code>def square(x: int) -&gt; int:\n    return x * x\n\nnums = [1, 2, 3, 4]\nsquares = list(map(square, nums))\nprint(squares)  # \u279c [1, 4, 9, 16]\n#example with Lambda function\nsquares = list(map(lambda x: x**2, nums))\nprint(squares)  # \u279c [1, 4, 9, 16]\n</code></pre>"},{"location":"python/memento_python/#decorators","title":"decorators","text":"<p>A decorator is a special type of function in Python that allows you to \"decorate\" or modify another function (or method) without changing its actual code. It allows you to add functionality to an existing function in a clean, readable way. <pre><code>def my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n</code></pre> Common Built-in Decorators Python provides a few built-in decorators that are commonly used. Here are some examples:</p> <p>a. @staticmethod A staticmethod is a method that belongs to the class but doesn't require an instance of the class to be called. It does not have access to self (instance) or cls (class). <pre><code>class MyClass:\n    @staticmethod\n    def say_hello():\n        print(\"Hello from a static method!\")\n</code></pre></p> <p>b. @classmethod A classmethod is a method that works with the class itself rather than instances. It takes cls as the first argument, which refers to the class. <pre><code>class MyClass:\n    @classmethod\n    def say_hello(cls):\n        print(f\"Hello from {cls}!\")\n</code></pre> c. @property The @property decorator turns a method into a read-only property. Instead of calling it like a method, you access it like an attribute. <pre><code>class MyClass:\n    def __init__(self, x):\n        self._x = x\n\n    @property\n    def x(self):\n        return self._x\n</code></pre></p>"},{"location":"sql/memento_sql/","title":"Memento SQL","text":""},{"location":"tdd/memento_tdd/","title":"Memento Test Drive Developement","text":""}]}